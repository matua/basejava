package com.matuageorge.webapp.storage;import com.matuageorge.webapp.exception.StorageException;import com.matuageorge.webapp.model.Resume;import com.matuageorge.webapp.service.ObjectStreamSerialization;import java.io.*;import java.util.Arrays;import java.util.List;import java.util.Objects;import java.util.stream.Collectors;import java.util.stream.Stream;public class FileStorage extends AbstractStorage<File> {    private final File directory;    private final ObjectStreamSerialization objectstreamSerialization;    protected FileStorage(File directory, ObjectStreamSerialization objectstreamSerialization) {        this.objectstreamSerialization = objectstreamSerialization;        Objects.requireNonNull(directory, "directory must not be null");        if (!directory.isDirectory()) {            throw new IllegalArgumentException(directory.getAbsolutePath() + "is not a directory");        }        if (!directory.canRead() && !directory.canWrite()) {            throw new IllegalArgumentException(directory.getAbsolutePath() + "is not readable/writable");        }        this.directory = directory;    }    @Override    protected File getKey(String uuid) {        return new File(directory, uuid);    }    @Override    protected void innerUpdate(Resume resume, File file) {        try {            objectstreamSerialization.doWrite(resume, new BufferedOutputStream(new FileOutputStream(file)));        } catch (IOException e) {            throw new StorageException("IO error", resume.getUuid(), e);        }    }    @Override    protected void innerSave(Resume resume, File file) {        try {            final boolean newFile = file.createNewFile();        } catch (IOException e) {            throw new StorageException("Couldn't create file " + file.getAbsolutePath(), file.getName(), e);        }        innerUpdate(resume, file);    }    @Override    protected void innerDelete(File file) {        if (!file.delete()) {            throw new StorageException("File does not exist", file.getName());        }    }    @Override    protected Resume innerGet(File file) {        try {            return objectstreamSerialization.fileToResume(new BufferedInputStream(new FileInputStream(file)));        } catch (IOException e) {            throw new StorageException("File read error", file.getName(), e);        }    }    @Override    protected boolean isExist(File file) {        return file.exists();    }    @Override    protected List<Resume> innerGetAllSorted() {        return returnFilesList()                .map(this::innerGet)                .collect(Collectors.toList());    }    @Override    public void clear() {        returnFilesList().forEach(this::innerDelete);    }    @Override    public int size() {        return (int) returnFilesList().count();    }    protected Stream<File> returnFilesList() {        return Arrays.stream(Objects.requireNonNull(directory.listFiles()));    }}